<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RHEL SOS Analyzer v18.3 (SAR Format Fix)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --sidebar-width: 260px; --bg-dark: #1e1e2f; --accent: #0d6efd; }
        body { background-color: #f4f6f9; font-family: 'Segoe UI', Roboto, sans-serif; height: 100vh; overflow: hidden; display: flex; }
        
        .sidebar { width: var(--sidebar-width); background: var(--bg-dark); color: #fff; display: flex; flex-direction: column; flex-shrink: 0; }
        .nav-link { color: rgba(255,255,255,0.7); padding: 12px 20px; cursor: pointer; border-left: 3px solid transparent; }
        .nav-link:hover, .nav-link.active { color: #fff; background: rgba(255,255,255,0.1); border-left-color: var(--accent); }
        .main-content { flex: 1; overflow-y: auto; padding: 25px; }
        
        .card { border: none; box-shadow: 0 2px 8px rgba(0,0,0,0.05); margin-bottom: 20px; }
        .card-header { font-weight: 600; background: #fff; border-bottom: 1px solid #eee; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; }
        .source-badge { font-size: 0.75rem; color: #fff; background-color: #6c757d; padding: 2px 8px; border-radius: 4px; font-weight: normal; font-family: monospace; }
        .console-box { background: #2d2d3b; color: #e0e0e0; font-family: 'Consolas', monospace; padding: 15px; border-radius: 6px; white-space: pre-wrap; font-size: 0.85rem; max-height: 400px; overflow-y: auto; }
        
        /* Upload Area */
        .upload-wrapper { height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; }
        .upload-box { border: 2px dashed #ccc; padding: 60px; border-radius: 16px; background: #fff; text-align: center; cursor: pointer; width: 600px; transition: all 0.2s; user-select: none; }
        .upload-box:hover, .upload-box.drag-over { border-color: var(--accent); background: #f0f8ff; transform: scale(1.02); }
        .upload-icon { font-size: 3rem; margin-bottom: 15px; color: #6c757d; }
        
        .sortable-th { cursor: pointer; user-select: none; }
        .sortable-th:hover { background-color: #e9ecef; }
        .sort-icon { font-size: 0.8em; margin-left: 5px; color: #999; }

        .log-container { display: flex; height: calc(100vh - 120px); gap: 15px; border: 1px solid #ddd; background: #fff; border-radius: 8px; overflow: hidden; }
        .log-tree { width: 30%; background: #f8f9fa; border-right: 1px solid #ddd; overflow-y: auto; font-size: 0.9rem; }
        .log-viewer { width: 70%; background: #1e1e1e; color: #ccc; font-family: monospace; padding: 15px; overflow-y: auto; white-space: pre; font-size: 0.85rem; display: flex; flex-direction: column; }
        .log-group { padding: 8px 15px; font-weight: bold; background: #e9ecef; border-bottom: 1px solid #dee2e6; font-size: 0.8rem; text-transform: uppercase; color: #555; }
        .log-item { padding: 6px 20px; cursor: pointer; border-bottom: 1px solid #f1f1f1; word-break: break-all; }
        .log-item:hover { background: #e2e6ea; color: #0d6efd; }
        .log-item.active { background: #0d6efd; color: #fff; }

        .chart-container { position: relative; height: 300px; width: 100%; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="p-3 fw-bold border-bottom border-secondary">RHEL SOS Analyzer v18.3</div>
        <nav class="nav flex-column mt-2">
            <a class="nav-link active" onclick="switchTab('dashboard')">üìä Á∏ΩË¶Ω (Dashboard)</a>
            <a class="nav-link" onclick="switchTab('host-info')">üñ•Ô∏è Á≥ªÁµ±Ë≥áË®ä (Host)</a>
            <a class="nav-link" onclick="switchTab('sar')">üìà ÊïàËÉΩÁõ£Êéß (SAR)</a>
            <a class="nav-link" onclick="switchTab('kernel')">‚öôÔ∏è Ê†∏ÂøÉËàáÊ®°ÁµÑ (Kernel)</a>
            <a class="nav-link" onclick="switchTab('network')">üåê Á∂≤Ë∑ØÁãÄÊÖã (Network)</a>
            <a class="nav-link" onclick="switchTab('logs')">üìù Êó•Ë™åÁÄèË¶ΩÂô® (Logs)</a>
            <a class="nav-link" onclick="switchTab('debug')">üêû Ê™îÊ°àÊ™¢Ê∏¨ (Debug)</a>
        </nav>
    </div>

    <div class="main-content">
        <div id="loader" class="alert alert-info hidden">Ê≠£Âú®Ëß£ÊûêÊ™îÊ°à...</div>

        <div id="view-upload" class="upload-wrapper">
            <div class="upload-box" id="drop-zone">
                <div class="upload-icon">üìÇ</div>
                <h4>‰∏äÂÇ≥ SOS Report</h4>
                <p class="text-muted">ÈªûÊìäÈÅ∏ÊìáË≥áÊñôÂ§æ Êàñ ÊãñÊõ≥Ëá≥Ê≠§<br><small>(ÊîØÊè¥ RHEL 7/8/9)</small></p>
            </div>
            <input type="file" id="dir-input" webkitdirectory directory multiple class="d-none">
        </div>

        <div id="view-dashboard" class="content-view hidden">
            <h4 class="mb-3">Á≥ªÁµ±Á∏ΩË¶Ω</h4>
            <div class="row g-3 mb-4">
                <div class="col-md-3"><div class="card p-3 text-center"><small class="text-muted">Hostname</small><div class="fw-bold text-primary" id="dash-hostname">-</div></div></div>
                <div class="col-md-3"><div class="card p-3 text-center"><small class="text-muted">Release</small><div class="fw-bold" id="dash-release">-</div></div></div>
                <div class="col-md-3"><div class="card p-3 text-center"><small class="text-muted">Kernel</small><div class="fw-bold small text-truncate" id="dash-kernel">-</div></div></div>
                <div class="col-md-3"><div class="card p-3 text-center"><small class="text-muted">Uptime</small><div class="fw-bold" id="dash-uptime">-</div></div></div>
            </div>
            
            <div class="row">
                <div class="col-md-4">
                    <div class="card h-100">
                        <div class="card-header">Memory Usage <span class="source-badge" id="src-mem">Pending</span></div>
                        <div class="card-body d-flex flex-column align-items-center justify-content-center">
                            <div style="width: 200px; height: 200px; position: relative;"><canvas id="memChart"></canvas></div>
                            <div class="mt-3 small text-muted text-center" id="mem-text">Waiting...</div>
                        </div>
                    </div>
                </div>
                <div class="col-md-8">
                    <div class="card h-100">
                        <div class="card-header">
                            <span>Top Processes</span>
                            <span class="source-badge" id="src-ps-dash">Pending</span>
                        </div>
                        <div class="card-body p-0" style="max-height: 400px; overflow-y: auto;">
                            <table class="table table-sm table-hover table-striped mb-0 small sticky-top">
                                <thead class="table-light text-secondary" style="position: sticky; top: 0; z-index: 1;">
                                    <tr>
                                        <th class="sortable-th" onclick="sortProcs('pid')">PID <span id="sort-pid" class="sort-icon"></span></th>
                                        <th class="sortable-th" onclick="sortProcs('user')">USER <span id="sort-user" class="sort-icon"></span></th>
                                        <th class="sortable-th" onclick="sortProcs('mem')">MEM% <span id="sort-mem" class="sort-icon">‚ñº</span></th>
                                        <th class="sortable-th" onclick="sortProcs('cpu')">CPU% <span id="sort-cpu" class="sort-icon"></span></th>
                                        <th class="sortable-th" onclick="sortProcs('cmd')">COMMAND <span id="sort-cmd" class="sort-icon"></span></th>
                                    </tr>
                                </thead>
                                <tbody id="mem-table-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="view-sar" class="content-view hidden">
            <h4 class="mb-3">ÊïàËÉΩÊ≠∑Âè≤ (SAR Analysis) <span class="source-badge" id="src-sar">Pending</span></h4>
            <div class="card mb-3">
                <div class="card-header">CPU Load History (%user / %system / %iowait)</div>
                <div class="card-body">
                    <div class="chart-container"><canvas id="sarCpuChart"></canvas></div>
                </div>
            </div>
            <div class="card">
                <div class="card-header">Memory Usage History (%memused)</div>
                <div class="card-body">
                    <div class="chart-container"><canvas id="sarMemChart"></canvas></div>
                </div>
            </div>
        </div>

        <div id="view-network" class="content-view hidden">
             <h4 class="mb-3">Á∂≤Ë∑ØÂàÜÊûê</h4>
             <div class="card">
                <div class="card-header">
                    <div>Listening Ports <span class="source-badge" id="src-ss">Pending</span></div>
                    <div class="btn-group btn-group-sm" role="group">
                        <input type="radio" class="btn-check" name="net-source" id="btn-netstat" autocomplete="off" onchange="renderNetwork('netstat')">
                        <label class="btn btn-outline-secondary" for="btn-netstat">Netstat</label>
                        <input type="radio" class="btn-check" name="net-source" id="btn-ss" autocomplete="off" onchange="renderNetwork('ss')">
                        <label class="btn btn-outline-secondary" for="btn-ss">SS</label>
                    </div>
                </div>
                <div class="card-body"><div class="console-box" id="net-ss">Searching...</div></div>
            </div>
            <div class="card">
                <div class="card-header">IP Address <span class="source-badge" id="src-ip">Pending</span></div>
                <div class="card-body"><div class="console-box" id="net-ip">Searching...</div></div>
            </div>
        </div>

        <div id="view-host-info" class="content-view hidden">
            <h4 class="mb-3">Á°¨È´îËàá‰∏≠‰ªãËªüÈ´î</h4>
            <div class="card">
                <div class="card-header">Middleware Processes <span class="source-badge" id="src-ps-mid">Pending</span></div>
                <div class="card-body"><div class="console-box" id="info-middleware">Scanning...</div></div>
            </div>
            <div class="card">
                <div class="card-header">Hardware & BIOS <span class="source-badge" id="src-dmi">Pending</span></div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4"><strong>Model:</strong> <span id="info-model">-</span></div>
                        <div class="col-md-4"><strong>Vendor:</strong> <span id="info-vendor">-</span></div>
                        <div class="col-md-4"><strong>BIOS:</strong> <span id="info-bios">-</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="view-kernel" class="content-view hidden">
            <h4 class="mb-3">Ê†∏ÂøÉËàáÊ®°ÁµÑË≥áË®ä</h4>
            <div class="card">
                <div class="card-header">Loaded Kernel Modules (lsmod) <span class="source-badge" id="src-lsmod">Pending</span></div>
                <div class="card-body">
                    <div class="mb-2"><strong>Total Modules:</strong> <span id="lsmod-count">0</span></div>
                    <div class="table-responsive" style="max-height: 300px; overflow-y: auto;">
                        <table class="table table-sm table-striped small">
                            <thead><tr><th>Module</th><th>Size (KB)</th><th>Used By</th></tr></thead>
                            <tbody id="lsmod-body"><tr><td colspan="3">Scanning...</td></tr></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div class="card">
                <div class="card-header">
                    <div>Kernel Parameters (sysctl -a) <span class="source-badge" id="src-sysctl">Pending</span></div>
                    <input type="text" class="form-control form-control-sm w-25" placeholder="Search..." onkeyup="filterSysctl()" id="sysctl-search">
                </div>
                <div class="card-body p-0">
                    <div class="console-box" id="sysctl-box" style="background: #fff; color: #333; max-height: 500px; border-radius: 0;">Scanning...</div>
                </div>
            </div>
        </div>

        <div id="view-logs" class="content-view hidden">
            <h4 class="mb-3">Êó•Ë™åÁÄèË¶ΩÂô®</h4>
            <div class="log-container">
                <div class="log-tree" id="log-tree"><div class="p-3 text-muted">No files</div></div>
                <div class="log-viewer">
                    <div class="border-bottom pb-2 mb-2 d-flex justify-content-between">
                        <strong id="log-current-file">-</strong>
                        <input type="text" id="log-search-input" class="form-control form-control-sm w-25 bg-dark text-light border-secondary" placeholder="Search..." onkeyup="filterLogContent()">
                    </div>
                    <div class="log-content" id="log-content-area"></div>
                </div>
            </div>
        </div>

        <div id="view-debug" class="content-view hidden">
            <h4>File Index Debugger</h4>
            <div class="console-box" id="debug-list"></div>
        </div>
    </div>

    <script>
        const App = {
            files: new Map(), filePaths: [], cache: {}, 
            currentLogText: "", fullSysctlText: "", processList: [], 
            memChart: null, sarCpuChart: null, sarMemChart: null,
            netData: { ss: null, netstat: null }, 

            rules: {
                ps: [/ps_aux.*$/, /ps_auxwwwm$/], 
                netstat: [/netstat.*$/], 
                ss: [/ss.*$/],
                hostname: [/hostname$/],
                release: [/redhat-release$/],
                uptime: [/uptime$/],
                uname: [/uname_-a$/],
                dmidecode: [/dmidecode$/],
                ip: [/ip_-o_addr$/, /ip_addr$/, /ip_address$/, /ip_a$/, /ifconfig$/],
                lsmod: [/lsmod$/],
                sysctl: [/sysctl_-a$/],
                free: [/\/sos_commands\/memory\/free$/, /(^|\/)free$/], 
                meminfo: [/proc\/meminfo$/, /meminfo$/],
                sar: [
                    /sar_-A$/,                   
                    /sos_commands\/sar\/sar.*$/, 
                    /var\/log\/sa\/sar\d+$/,     
                    /sa\/sar$/                   
                ] 
            }
        };

        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('dir-input');

        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('drag-over'); });
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault(); dropZone.classList.remove('drag-over');
            const items = e.dataTransfer.items;
            if (!items) return;
            toggleLoader(true); resetState();
            const queue = [];
            for (let i = 0; i < items.length; i++) {
                const entry = items[i].webkitGetAsEntry();
                if (entry) queue.push(traverseFileTree(entry));
            }
            await Promise.all(queue);
            startAnalysis();
        });

        fileInput.addEventListener('change', async (e) => {
            const fileList = e.target.files;
            if (!fileList.length) return;
            toggleLoader(true); resetState();
            for (let f of fileList) {
                const parts = f.webkitRelativePath.split('/');
                const relPath = parts.slice(1).join('/');
                if (f.size > 0) { App.files.set(relPath, f); App.filePaths.push(relPath); }
            }
            startAnalysis();
        });

        function resetState() {
            App.files.clear(); App.filePaths = []; App.cache = {}; App.processList = []; App.netData = { ss: null, netstat: null };
            if (App.memChart) { App.memChart.destroy(); App.memChart = null; }
            if (App.sarCpuChart) { App.sarCpuChart.destroy(); App.sarCpuChart = null; }
            if (App.sarMemChart) { App.sarMemChart.destroy(); App.sarMemChart = null; }
        }

        async function traverseFileTree(item) {
            if (item.isFile) {
                return new Promise((resolve) => {
                    item.file((file) => {
                        let relPath = item.fullPath;
                        if (relPath.startsWith('/')) relPath = relPath.substring(1);
                        const cleanPath = relPath.split('/').slice(1).join('/');
                        if (cleanPath && file.size > 0) { App.files.set(cleanPath, file); App.filePaths.push(cleanPath); }
                        resolve();
                    });
                });
            } else if (item.isDirectory) {
                const dirReader = item.createReader();
                const entries = await readAllEntries(dirReader);
                await Promise.all(entries.map(e => traverseFileTree(e)));
            }
        }

        function readAllEntries(dirReader) {
            return new Promise((resolve) => {
                let entries = [];
                function read() {
                    dirReader.readEntries((result) => {
                        if (result.length === 0) resolve(entries);
                        else { entries = entries.concat(result); read(); }
                    });
                }
                read();
            });
        }

        async function startAnalysis() {
            try {
                let log = "--- Loaded Files ---\n";
                App.filePaths.forEach(p => log += p + "\n");
                document.getElementById('debug-list').textContent = log;

                await Promise.all([
                    runDashboard(), runMemoryAnalysis(), runHostInfo(), runKernel(), runNetwork(), runSarAnalysis(), buildLogTree()
                ]);
                document.getElementById('view-upload').classList.add('hidden');
                switchTab('dashboard');
            } catch (err) { console.error(err); alert("Error: " + err.message); } 
            finally { toggleLoader(false); }
        }

        async function findAndRead(ruleKey, validateFn = null) {
            const regexList = App.rules[ruleKey];
            if (!regexList) return { content: null, path: null };
            
            const matches = App.filePaths.filter(p => regexList.some(r => r.test(p)));
            if (matches.length === 0) return { content: null, path: null };
            
            matches.sort((a, b) => b.length - a.length);
            
            for (let path of matches) {
                if (path.includes('.gz') || path.includes('.xz')) continue;

                if (!App.cache[path]) App.cache[path] = await App.files.get(path).text();
                const content = App.cache[path];
                if (validateFn && !validateFn(content)) continue;
                return { content, path };
            }
            return { content: null, path: null };
        }

        // --- Network Analysis ---
        async function runNetwork() {
            const isValidPortList = (text) => {
                if (text.length < 30) return false;
                if (text.includes('TcpExt:') || text.includes('IpExt:') || text.includes('MPTcpExt:')) return false;
                if (text.startsWith('Total:') && text.includes('TCP:')) return false;
                if (text.includes('OS Type:') && text.includes('UUID:')) return false;
                const hasNetstatHeader = text.includes('Proto') && (text.includes('Address') || text.includes('Recv-Q'));
                const hasSSHeader = (text.includes('State') || text.includes('ESTAB')) && (text.includes('Netid') || text.includes('Address'));
                return hasNetstatHeader || hasSSHeader;
            };

            const net = await findAndRead('netstat', isValidPortList);
            if (net.content) App.netData.netstat = { content: net.content, path: net.path };

            const ss = await findAndRead('ss', isValidPortList);
            if (ss.content) App.netData.ss = { content: ss.content, path: ss.path };

            if (App.netData.netstat) {
                document.getElementById('btn-netstat').checked = true;
                renderNetwork('netstat');
            } else if (App.netData.ss) {
                document.getElementById('btn-ss').checked = true;
                renderNetwork('ss');
            } else {
                document.getElementById('net-ss').textContent = "No valid Port list found.";
                showSrc('src-ss', null);
            }

            const ip = await findAndRead('ip');
            showSrc('src-ip', ip.path);
            if (ip.content) document.getElementById('net-ip').textContent = ip.content;
            else document.getElementById('net-ip').textContent = "IP info not found.";
        }

        window.renderNetwork = function(type) {
            const data = App.netData[type];
            if (!data) { document.getElementById('net-ss').textContent = "Data not available"; return; }
            showSrc('src-ss', data.path);
            const lines = data.content.split('\n');
            let output = "";
            if (type === 'netstat') {
                const headers = lines.filter(l => l.includes('Proto'));
                output = [...headers, ...lines.filter(l => l.includes('LISTEN') || (l.includes('udp') && !l.includes('ESTAB')))].join('\n');
            } else {
                output = lines.filter(l => l.includes('State') || l.includes('LISTEN') || l.includes('UNCONN')).join('\n');
            }
            if (output.length < 50) output = lines.slice(0, 50).join('\n'); 
            document.getElementById('net-ss').textContent = output;
        };

        // --- SAR Analysis (Fixed for Abbreviated Headers) ---
        async function runSarAnalysis() {
            // Validator: text file with headers
            const isSarText = (t) => (t.includes('CPU') || t.includes('%usr') || t.includes('%user')) && !t.includes('<?xml');

            const sar = await findAndRead('sar', isSarText);
            showSrc('src-sar', sar.path);
            
            if (!sar.content) {
                document.getElementById('sarCpuChart').parentNode.innerHTML = '<div class="alert alert-secondary">SAR data not found.</div>';
                document.getElementById('sarMemChart').parentNode.innerHTML = '<div class="alert alert-secondary">SAR data not found.</div>';
                return;
            }

            const lines = sar.content.split('\n');
            const timestamps = [];
            const cpuData = { user: [], system: [], iowait: [] };
            const memData = { used: [] };
            
            let section = null; 
            let colMap = {};

            const splitL = (l) => l.trim().split(/\s+/);

            for (let i = 0; i < lines.length; i++) {
                const l = lines[i].trim();
                if (!l) continue;
                if (l.startsWith('Average:')) continue; 

                const parts = splitL(l);
                
                // --- FIXED: Flexible Header Detection (%user or %usr, %system or %sys) ---
                if ((l.includes('%user') || l.includes('%usr')) && (l.includes('%idle') || l.includes('%system') || l.includes('%sys'))) {
                    section = 'CPU';
                    
                    // Determine indices dynamically
                    let idxUser = parts.indexOf('%user');
                    if (idxUser === -1) idxUser = parts.indexOf('%usr'); // Fallback to abbr
                    
                    let idxSys = parts.indexOf('%system');
                    if (idxSys === -1) idxSys = parts.indexOf('%sys');   // Fallback to abbr

                    let idxIo = parts.indexOf('%iowait');

                    colMap = { user: idxUser, sys: idxSys, io: idxIo };
                    
                    // Abort if critical column still missing
                    if (colMap.user === -1) section = null; 
                    continue;
                }

                // Memory Header Detection
                // Check for 'kbmemused' OR 'mbmemused' OR just '%memused'
                if ((l.includes('kbmemused') || l.includes('mbmemused') || l.includes('%memused')) && (l.includes('%memused') || l.includes('kbmemfree'))) {
                    section = 'MEM';
                    colMap = { mem: parts.indexOf('%memused') };
                    if (colMap.mem === -1) section = null;
                    continue;
                }

                // Reset on other sections
                if (l.includes('kbswpused') || l.includes('DEV') || l.includes('IFACE') || l.includes('tps') || l.includes('filesystem')) {
                    section = null; 
                    continue;
                }

                // Data Parsing
                if (!/^\d{2}:\d{2}:\d{2}/.test(parts[0])) continue;

                if (section === 'CPU') {
                    let offset = 0;
                    if (parts[1] === 'AM' || parts[1] === 'PM') offset = 1;
                    
                    // Check if row is for a specific CPU core (numeric) or 'all'
                    const cpuColVal = parts[1 + offset]; 
                    // If it is a number (specific core), skip it. Keep only 'all'.
                    // Note: !isNaN('0') is true. !isNaN('all') is false.
                    if (!isNaN(parseFloat(cpuColVal)) && parts.length > 5) continue; 
                    
                    const idxUser = colMap.user + offset; 
                    if (parts[idxUser]) {
                         const t = parts[0] + (offset ? ' ' + parts[1] : '');
                         if (timestamps.indexOf(t) === -1) timestamps.push(t);
                         
                         // Sync data arrays
                         if (timestamps.length > cpuData.user.length) {
                             cpuData.user.push(parseFloat(parts[idxUser]) || 0);
                             cpuData.system.push(parseFloat(parts[colMap.sys + offset]) || 0);
                             cpuData.iowait.push(parseFloat(parts[colMap.io + offset]) || 0);
                         }
                    }
                }
                else if (section === 'MEM') {
                    let offset = 0;
                    if (parts[1] === 'AM' || parts[1] === 'PM') offset = 1;
                    const idxMem = colMap.mem + offset;
                    if (parts[idxMem]) {
                        memData.used.push(parseFloat(parts[idxMem]) || 0);
                    }
                }
            }

            if (timestamps.length > 0) {
                const ctxCpu = document.getElementById('sarCpuChart').getContext('2d');
                App.sarCpuChart = new Chart(ctxCpu, {
                    type: 'line',
                    data: {
                        labels: timestamps,
                        datasets: [
                            { label: '%User', data: cpuData.user, borderColor: '#0d6efd', fill: false, tension: 0.1 },
                            { label: '%System', data: cpuData.system, borderColor: '#dc3545', fill: false, tension: 0.1 },
                            { label: '%IOWait', data: cpuData.iowait, borderColor: '#ffc107', fill: false, tension: 0.1 }
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false } }
                });
            }

            if (memData.used.length > 0) {
                const memLabels = timestamps.slice(0, memData.used.length);
                const ctxMem = document.getElementById('sarMemChart').getContext('2d');
                App.sarMemChart = new Chart(ctxMem, {
                    type: 'line',
                    data: {
                        labels: memLabels,
                        datasets: [{ label: '% MemUsed', data: memData.used, borderColor: '#198754', backgroundColor: 'rgba(25, 135, 84, 0.1)', fill: true, tension: 0.1 }]
                    },
                    options: { responsive: true, maintainAspectRatio: false, scales: { y: { min: 0, max: 100 } } }
                });
            }
        }

        // --- Memory Chart ---
        async function runMemoryAnalysis() {
            let mem = await findAndRead('free');
            let total = 0, used = 0, free = 0, buff = 0, src = '';
            
            if (mem.content && !mem.content.includes('Mem:')) mem.content = null;

            if (mem.content) {
                src = mem.path;
                const lines = mem.content.split('\n');
                const memLine = lines.find(l => l.trim().startsWith('Mem:'));
                if (memLine) {
                    const parts = memLine.trim().split(/\s+/);
                    total = parseFloat(parts[1]); used = parseFloat(parts[2]); free = parseFloat(parts[3]); 
                    if (parts.length > 6) buff = parseFloat(parts[5]); 
                    else buff = 0;
                }
            } else {
                mem = await findAndRead('meminfo');
                if (mem.content) {
                    src = mem.path;
                    const getVal = (k) => { const m = mem.content.match(new RegExp(`^${k}:\\s+(\\d+)`, 'm')); return m ? parseInt(m[1]) : 0; };
                    total = getVal('MemTotal'); free = getVal('MemFree'); buff = getVal('Buffers') + getVal('Cached') + getVal('SReclaimable'); used = total - free - buff;
                }
            }
            showSrc('src-mem', src);
            if (total > 0) {
                renderMemChart(used, free, buff);
                const toGB = (v) => (v / 1024 / 1024).toFixed(1) + ' GB';
                document.getElementById('mem-text').innerHTML = `Total: ${toGB(total)}<br>Used: ${toGB(used)} | Free: ${toGB(free)} | Cache: ${toGB(buff)}`;
            } else { 
                document.getElementById('mem-text').textContent = "No data (Check 'free' or 'meminfo')"; 
                if (App.memChart) App.memChart.destroy();
            }
        }

        function renderMemChart(used, free, buff) {
            const ctx = document.getElementById('memChart').getContext('2d');
            if (App.memChart) App.memChart.destroy();
            App.memChart = new Chart(ctx, {
                type: 'doughnut',
                data: { labels: ['Used', 'Free', 'Buff/Cache'], datasets: [{ data: [used, free, buff], backgroundColor: ['#dc3545', '#198754', '#ffc107'], borderWidth: 0 }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, cutout: '70%' }
            });
        }

        // --- Process Table ---
        async function runHostInfo() {
            const ps = await findAndRead('ps');
            showSrc('src-ps-dash', ps.path); showSrc('src-ps-mid', ps.path);
            if (ps.content) {
                const lines = ps.content.split('\n');
                let hIdx = -1;
                for(let i=0; i<Math.min(50, lines.length); i++) { if (lines[i].includes('PID') && lines[i].includes('%MEM')) { hIdx = i; break; } }
                if (hIdx !== -1) {
                    const parsed = [];
                    for (let i = hIdx + 1; i < lines.length; i++) {
                        const l = lines[i].trim(); if (!l) continue;
                        const p = l.split(/\s+/);
                        if (p[1] === '-' || isNaN(parseInt(p[1]))) continue;
                        if (p.length < 10) continue;
                        const mem = parseFloat(p[3]); const cpu = parseFloat(p[2]);
                        if (!isNaN(mem)) parsed.push({ user: p[0], pid: parseInt(p[1]), mem, cpu, cmd: p.slice(10).join(' ') });
                    }
                    App.processList = parsed;
                    sortProcs('mem', 'desc');
                    const mwRegex = /java|python|node|httpd|nginx|mysql|postgres|docker|kube/i;
                    const mw = parsed.filter(p => mwRegex.test(p.cmd) && !p.cmd.includes(' grep '));
                    document.getElementById('info-middleware').textContent = mw.length ? mw.map(p=>`${p.user} (${p.pid}): ${p.cmd}`).join('\n') : "No common middleware found.";
                }
            }
            const dmi = await findAndRead('dmidecode');
            showSrc('src-dmi', dmi.path);
            if(dmi.content) {
                const prod = (dmi.content.match(/Product Name:\s*(.+)/)||[])[1];
                const vend = (dmi.content.match(/Manufacturer:\s*(.+)/)||[])[1];
                const bios = (dmi.content.match(/Version:\s*(.+)/)||[])[1];
                if(prod) document.getElementById('info-model').textContent = prod; if(vend) document.getElementById('info-vendor').textContent = vend; if(bios) document.getElementById('info-bios').textContent = bios;
            }
        }

        let currentSort = { key: 'mem', order: 'desc' };
        window.sortProcs = function(key) {
            if (currentSort.key === key) currentSort.order = currentSort.order === 'desc' ? 'asc' : 'desc';
            else { currentSort.key = key; currentSort.order = 'desc'; }
            document.querySelectorAll('.sort-icon').forEach(el => el.textContent = '');
            document.getElementById(`sort-${currentSort.key}`).textContent = currentSort.order === 'desc' ? '‚ñº' : '‚ñ≤';
            const sorted = [...App.processList].sort((a, b) => {
                if (key === 'cmd' || key === 'user') return currentSort.order === 'asc' ? a[key].localeCompare(b[key]) : b[key].localeCompare(a[key]);
                return currentSort.order === 'asc' ? a[key] - b[key] : b[key] - a[key];
            });
            document.getElementById('mem-table-body').innerHTML = sorted.slice(0, 50).map(p => `<tr><td>${p.pid}</td><td>${p.user}</td><td>${p.mem}%</td><td>${p.cpu}%</td><td class="text-truncate" style="max-width:200px" title="${p.cmd}">${p.cmd}</td></tr>`).join('');
        };

        // --- Other Modules ---
        async function runDashboard() {
            const h = await findAndRead('hostname'); if(h.content) document.getElementById('dash-hostname').textContent = h.content.trim();
            const r = await findAndRead('release'); if(r.content) document.getElementById('dash-release').textContent = r.content.split('\n')[0];
            const u = await findAndRead('uptime'); if(u.content) document.getElementById('dash-uptime').textContent = u.content.trim();
            const k = await findAndRead('uname'); if(k.content) { const p = k.content.split(' '); document.getElementById('dash-kernel').textContent = p.length>=3?p[2]:k.content; }
        }
        async function runKernel() {
            const ls = await findAndRead('lsmod'); showSrc('src-lsmod', ls.path);
            if(ls.content) {
                const lines = ls.content.split('\n');
                let mods = []; lines.forEach(l=>{const p=l.split(/\s+/); if(p.length>=2&&p[0]!=='Module'){const s=parseInt(p[1]);if(!isNaN(s))mods.push({name:p[0],size:s,used:p[2]||'-'});}});
                document.getElementById('lsmod-count').textContent = mods.length;
                document.getElementById('lsmod-body').innerHTML = mods.sort((a,b)=>b.size-a.size).slice(0,10).map(m=>`<tr><td>${m.name}</td><td>${(m.size/1024).toFixed(2)} KB</td><td>${m.used}</td></tr>`).join('');
            }
            const sys = await findAndRead('sysctl'); showSrc('src-sysctl', sys.path);
            if(sys.content) { App.fullSysctlText = sys.content; filterSysctl(); }
        }
        function filterSysctl() {
            const t = document.getElementById('sysctl-search').value.toLowerCase();
            const lines = App.fullSysctlText.split('\n');
            document.getElementById('sysctl-box').textContent = (t ? lines.filter(l=>l.toLowerCase().includes(t)) : lines.slice(0,100)).join('\n');
        }
        function buildLogTree() {
            const tree = document.getElementById('log-tree'); tree.innerHTML = '';
            const cats = { "System": [/messages/, /dmesg/, /boot/], "Security": [/secure/, /audit/], "Package": [/dnf/, /yum/], "Cron": [/cron/], "Others": [] };
            const found = { "System": [], "Security": [], "Package": [], "Cron": [], "Others": [] };
            App.filePaths.forEach(p => {
                if (!p.match(/var\/log|sos_commands\/logs|dmesg/)) return;
                if (p.match(/\.gz$|wtmp|lastlog/)) return;
                let m = false; for(let c in cats){ if(c==='Others')continue; if(cats[c].some(r=>r.test(p))){ found[c].push(p); m=true; break; } }
                if(!m && p.includes('var/log')) found['Others'].push(p);
            });
            for(let c in found) {
                if(!found[c].length) continue;
                const g = document.createElement('div'); g.className='log-group'; g.textContent=c; tree.appendChild(g);
                found[c].sort().forEach(p => { const i=document.createElement('div'); i.className='log-item'; i.textContent=p.split('/').pop(); i.onclick=()=>loadLog(p,i); tree.appendChild(i); });
            }
        }
        async function loadLog(path, el) {
            document.querySelectorAll('.log-item').forEach(e=>e.classList.remove('active')); el.classList.add('active');
            document.getElementById('log-current-file').textContent = path;
            const v = document.getElementById('log-content-area'); v.textContent = "Loading...";
            let t = await App.files.get(path).text();
            if(t.length > 50000) t = `[Truncated last 50k]\n` + t.slice(-50000);
            App.currentLogText = t; v.textContent = t; v.scrollTop = v.scrollHeight;
        }
        function filterLogContent() {
            const t = document.getElementById('log-search-input').value.toLowerCase();
            document.getElementById('log-content-area').textContent = t ? App.currentLogText.split('\n').filter(l=>l.toLowerCase().includes(t)).join('\n') : App.currentLogText;
        }
        function toggleLoader(s) { document.getElementById('loader').classList.toggle('hidden', !s); }
        function showSrc(id, p) { const el=document.getElementById(id); if(el) el.textContent = p?`SRC: .../${p.split('/').pop()}`:'Not Found'; }
        function switchTab(id) {
            document.querySelectorAll('.content-view').forEach(e=>e.classList.add('hidden'));
            document.getElementById('view-'+id).classList.remove('hidden');
            document.querySelectorAll('.nav-link').forEach(e=>e.classList.remove('active'));
            const nav = Array.from(document.querySelectorAll('.nav-link')).find(n=>n.getAttribute('onclick').includes(id));
            if(nav) nav.classList.add('active');
            if(id === 'sar' && App.sarCpuChart) { App.sarCpuChart.resize(); App.sarMemChart.resize(); }
            if(id === 'dashboard' && App.memChart) App.memChart.resize();
        }
    </script>
</body>
</html>